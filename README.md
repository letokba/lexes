# lexes

a simple Four Operations Expression Analyzer.



## 测试样本

```text
    "1 + 2",                            // 3
    "2 + 3 * 2",                        // 8
    "3 - 2 / 2 * 4 + 4",                // 3
    "(1 + 2)",                          // 3
    "(1 + 2) * 3",                      // 9
    "(2 - 1) + (3 + 1)",                // 5
    "(2.5 - 0.5) * 2",                  // 4
    "((3.0 + 2) * 2) + 0 + (2 * 3)"     // 16
    "3 + (2 + 3) * 3"                   // 18

```

## 测试结果

```text

    1 + 2 = 3.0
    2 + 3 * 2 = 8.0
    3 - 2 / 2 * 4 + 4 = 3.0
    (1 + 2) = 3.0
    (1 + 2) * 3 = 9.0
    (2 - 1) + (3 + 1) = 5.0
    (2.5 - 0.5) * 2 = 4.0
    ((3.0 + 2) * 2) + 0 + (2 * 3) = 16.0
    3 + (2 + 3) * 3 = 18.0

```

## 基本思路

### 生成队列

![生成队列](assets/created-symbols-queue.png)

### 生成符号树

这里，将例如“(2 + 3)”这样的子表达式，在符号树等价于 “5”，可以想象为二叉树上可以折叠的节点。所以当父节点为“(”，其右节点一定是”)“。
虽然乘法和除法的优先级高于加法和减法，在二叉树中却相反。当`*`遇到`+`将成为它右孩子，而非向一般的成为父节点。

#### 规则

- `(` 和数字一定位于右节点（除了表达式中出现的第一个数字）。
- `(` 是子表达式开启的标志，只能短暂的拥有`Root`指针。
- `)`一定是左节点，其父节点一定是`(`
- `)` 运算优先级位于高优先级的节点下方。

#### 具体过程

1. 初始化树，根节点默认为 `(`, 记为 `Root`指针。同时为其右节点设置一个 `)`节点；
2. 设置一个 `p` 节点记录根节点
3. 依次从队列中取出符号，生成节点，记为`ei`
   1. 如果 `ei` 为Number或者`(`时, 
      - 将`ei`设为右节点（若`Root`的右节点非空，不断向右查找其右节点）。根据规则2可知，如果父节点时`(`或者`ei`为
        `(`都需要向将`Root`指针向下传递（即其右节点用于`Root`指针）。

   2. 如果 `ei` 为 运算符时
      - 将`Root`指向的节点及其子树转移到`ei`的左节点上，`ei`取代`Root`在树中的位置，`Root`指针重新指向`ei`（这里`Root`指针位置上没有移动）
      - 例外，当`Root`指向运算符节点且`ei`的优先级低于 `Root`（例如，`*` 遇到 `+`），将`ei`取代`Root`的右节点，将原右节点移动到`ei`的左节点上，
   
   3. 如果 `ei` 为 `)`时
      - `Root`指针跳回到其父节点位置，设置其右节点为 `ei`。
4. 队列为空后，返回`p`的右子树，即可。

## 遍历树

构建完符号树，采用后序遍历，从下至上进行运算。运算规则为，若游标节点处在运算符节点上，执行 `左节点 @ 右节点`（其中 @代表运算符）；
如果处在左括号节点上，只需要节点的把其右节点的值copy过来，以便向上传递。

## 获取结果

最后，符号数的根节点的值即为文本表达式的运算结果。



------------

## 演示

![](assets/2020-12-24-17-09-18.gif)
